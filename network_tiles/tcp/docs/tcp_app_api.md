# TCP Engine API
## Overview
The default TCP engine API exposed by Buckfast in `tcp_hw` is access to the
pointers in the RX and TX circular buffers. The app is responsible for
polling/adjusting the appropriate pointers, which are described in more detail
below. This is suitable for one application or _maybe_ a small number of
applications. However, it is not great for scaling to $n$ applications, because
of the arbitration. It also is not particularly suitable for use over a NoC due
to the traffic generated by polling.

## Circular Buffer API
The TCP engine maintains fixed size (determined at compile/design time) circular
buffers per-flow. Also for ease of arithmetic, the fixed size is a power of 2.
There is one for receive and one for transmit. Both have 3 pointers. Note that
these circular buffers assume one application is using the flow. Any arbitration
that needs to occur to share the circular buffers needs to be done by the
application.

For the receive-side buffers, the pointers are head, tail, and commit, whose purposes are as follows
- `rx_head`: points at the next byte that the app should dequeue
- `rx_commit`: points at the byte where the next valid received packet for the
flow should be copied to
- `rx_tail`: points at the next empty byte that can be allocated

The logical relationship between these three pointers is that `rx_head` <=
`rx_commit` <= `rx_tail`. Note that a strict arithmetic comparison of the actual
values on the wire is not correct, because the top bit is used to determine if
the pointers have looped.

The reason we need 3 is because of how the RX pipe handles payloads.
Essentially, on arrival, each packet is temporarily allocated a buffer from a
slab allocator that maintains a small number of buffers. If the packet is valid,
it has space reserved in the per-flow buffer by adjusting `rx_tail`. However, to
not block the pipe on the copy of the packet to a larger buffer, the packet is
copied by another module. This module is responsible for adjusting `rx_commit`
once the data has actually been copied into the buffer. 

The way to think about the relationship between the 3 pointers is that the bytes
between `rx_head` and `rx_commit` have valid data, the bytes between `rx_head`
and `rx_tail` are allocated, and the bytes between `rx_commit` and `rx_tail` are
allocated, but not valid yet. The application should poll on the number of bytes
between `rx_head` and `rx_commit` to determine if there is a full message for it
to process. After consuming the message, it should adjust `rx_head` however many
bytes it consumed.

For the send-side buffers, the pointers are head, tail, and sent. Sent is not
actually stored, but is instead a logical pointer from the sequence number
of the flow. Their purpose is as follows

- `tx_head`: points at the first unacknowledged byte
- `tx_sent`: calculated from current sequence number mod the buffer size. points at the next byte to be sent
- `tx_tail`: points at the next empty byte that can be allocated by the application

The way to think about the relationship between the 3 pointers is that the bytes
between `tx_head` and `tx_sent` have been sent but are unacknowledged. The bytes
between `tx_sent` and `tx_tail` have been enqueued by the application, but have
not yet been sent. `tx_head` is actually adjusted by the RX pipe when it
receives a valid ACK for the connection. The application should poll on the
number of bytes between `rx_tail` and `rx_head` to determine if there is space
for it to enqueue its buffer. If there is room, it can copy the bytes into the
space starting at `tx_tail`. After it is finished copying, it should adjust
`tx_tail` the number of bytes it enqueued.

## NoC/dedicated poller API
This is designed to cut down on the amount of traffic apps have to send in order
to poll on buffers.

- `RX_REQ_MSG`: this should be sent with a flowID and length. This will let the
poller know that it should be looking for at least `length` bytes in the
circular buffer for flow `flowID`. When the poller sees that the buffer has
enough data to satisfy the request, the application will receive an descriptor
with offset into the flow's circular buffer and length. However, it doesn't send
the data and no memory in the circular buffer is freed at this point

- `RX_ADJUST_PTR`: this should be sent with flowID and length after the
application has either processed or copied the data from the buffer. This will
adjust the head pointer to reclaim the circular buffer space.

- `TX_REQ_MSG`: this should be sent with a flowID and length. This will let the
poller know it should be looking for at least `length` empty bytes in the
circular buffer for flow `flowID`. When the poller sees that there is enough
room in the buffer to satisfy the request, the application will receive a
descriptor with offset into the flow's circular buffer and length. However, the
buffer is not reserved at this point.

- `TX_ADJUST_PTR`: this should be sent with flowID and length after the
application has copied the data into the buffer. This will adjust the tail
pointer for the engine.
